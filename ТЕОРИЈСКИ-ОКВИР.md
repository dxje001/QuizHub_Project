# 2. ТЕОРИЈСКИ ОКВИР

## 2.1 Монолитна архитектура

Монолитна архитектура представља традиционални приступ развоју софтверских апликација у коме се целокупна апликација развија, deployује и извршава као јединствена, недељива целина. У монолитној архитектури, сви компоненти апликације - презентациони слој, пословна логика и слој за приступ подацима - интегрисани су у једну извршну јединицу која се deployује на серверу.

### 2.1.1 Карактеристике монолитне архитектуре

Монолитна архитектура карактерише се следећим особинама:

**Јединствена база кôда** - Целокупна апликација развија се као један пројекат са заједничком базом изворног кôда. Сви програмери раде на истом репозиторијуму и деле исте ресурсе.

**Јединствен процес deployовања** - Апликација се deployује као једна целина. Свака измена, без обзира колико мала, захтева поновно deployовање целокупне апликације.

**Једна извршна инстанца** - Апликација се извршава као један процес на серверу. Све компоненте деле исте системске ресурсе попут меморије и процесорског времена.

**Дељена база података** - Сви модули апликације приступају истој бази података, често користећи заједничке табеле и структуре података.

**Синхрона комуникација** - Компоненти унутар монолитне апликације комуницирају директним позивима метода и функција, без мрежне комуникације.

### 2.1.2 Предности монолитне архитектуре

Монолитна архитектура нуди бројне предности, посебно за мање пројекте и тимове:

**Једноставност развоја** - Развој монолитне апликације је релативно једноставан. Програмери раде у једном окружењу са познатим алатима и технологијама. Није потребно управљати сложеном инфраструктуром или координацијом између различитих сервиса.

**Једноставно тестирање** - Тестирање монолитне апликације је директно. Сви компоненти су присутни у истој инстанци, што олакшава интеграционо тестирање. Није потребно подизати више различитих сервиса за извршавање тестова.

**Брзи развој у раним фазама** - У раним фазама пројекта, монолитна архитектура омогућава брз развој нових функционалности. Програмери могу брзо додавати нове модуле без потребе за конфигурисањем сервиса или API интеграцијом.

**Мање оптерећење инфраструктуре** - Монолитна апликација захтева једноставнију инфраструктуру. Довољан је један сервер или кластер сервера који извршавају исту инстанцу апликације.

**Бољи перформанси локалне комуникације** - Комуникација између компоненти одвија се кроз директне позиве метода у меморији, што је значајно брже од мрежне комуникације.

**Једноставније deployовање** - Deployовање монолитне апликације је једноставан процес који обухвата копирање једне извршне јединице на сервер.

### 2.1.3 Недостаци монолитне архитектуре

Упркос предностима, монолитна архитектура има значајна ограничења:

**Отежано скалирање** - Скалирање монолитне апликације може бити неефикасно. Када је потребно скалирати само један модул апликације, неопходно је скалирати целокупну апликацију, што доводи до неоптималног коришћења ресурса.

**Технолошка зависност** - Цела апликација обично користи исти програмски језик, framework и технологије. Промена технологије или коришћење различитих решења за различите делове апликације је отежано.

**Повећана сложеност са растом апликације** - Како апликација расте, база кôда постаје све већа и сложенија. Програмерима постаје теже да разумеју целокупан систем, што успорава развој нових функционалности.

**Дуго време deployовања** - Са порастом величине апликације, време потребно за build, тестирање и deployовање се значајно повећава.

**Високи ризик при deployовању** - Свака измена, чак и мала, захтева deployовање целокупне апликације. Грешка у једном модулу може онемогућити рад целе апликације.

**Отежана паралелизација развоја** - Када више тимова ради на истој бази кôда, долази до конфликата и потребе за константном координацијом. Независан развој различитих функционалности је отежан.

## 2.2 Микросервисна архитектура

Микросервисна архитектура представља архитектурни приступ у коме се апликација структурира као колекција малих, аутономних сервиса. Сваки сервис је независна компонента која обавља специфичну пословну функцију и комуницира са другим сервисима преко добро дефинисаних API интерфејса, обично коришћењем HTTP/REST протокола.

### 2.2.1 Карактеристике микросервисне архитектуре

Микросервисна архитектура дефинише се следећим кључним карактеристикама:

**Декомпозиција по пословним функцијама** - Апликација је подељена на мале сервисе где сваки сервис одговара одређеној пословној функцији или домену. Ова декомпозиција прати принципе domain-driven design-а.

**Независност deployовања** - Сваки микросервис може бити deployован, ажуриран или скалиран независно од других сервиса. Промена у једном сервису не захтева deployовање других сервиса.

**Децентрализована управљања подацима** - Сваки микросервис управља својом базом података. Не постоји једна централна база података коју деле сви сервиси, што обезбеђује већу независност и флексибилност.

**Мрежна комуникација** - Микросервиси комуницирају међусобно преко мреже користећи протоколе као што су HTTP/REST, gRPC или message queue системе. Ова комуникација је по природи асинхрона или синхрона преко мреже.

**Технолошка хетерогеност** - Различити сервиси могу бити имплементирани коришћењем различитих програмских језика, framework-а и технологија, у зависности од специфичних захтева сваког сервиса.

**Аутоматизација и DevOps** - Микросервисна архитектура захтева висок ниво аутоматизације за build, тестирање, deployовање и мониторинг услед великог броја независних компоненти.

### 2.2.2 Предности микросервисне архитектуре

Микросервисна архитектура нуди значајне предности за велике и сложене системе:

**Независно скалирање** - Сваки сервис може бити скалиран независно у зависности од својих специфичних потреба. Ако један сервис има велико оптерећење, може се скалирати без утицаја на друге сервисе.

**Технолошка флексибилност** - Тимови могу бирати најбоље технологије за сваки сервис. Један сервис може користити Python са PostgreSQL базом података, док други користи Node.js са MongoDB базом.

**Паралелизација развоја** - Различити тимови могу радити на различитим сервисима истовремено без интерференције. Сваки тим има пуну контролу над својим сервисом.

**Изолација грешака** - Грешка у једном сервису неће нужно угрозити рад целог система. Сервиси могу бити дизајнирани да издрже пад других сервиса коришћењем pattern-а као што су circuit breaker и fallback механизми.

**Бржа time-to-market** - Мањи сервиси могу бити развијени, тестирани и deployовани брже него велики монолитни системи. Промене се могу испоручивати у production окружење чешће.

**Боље коришћење ресурса** - Могуће је прецизно алоцирати ресурсе сваком сервису према његовим потребама, уместо да се сви ресурси алоцирају целој апликацији.

### 2.2.3 Недостаци микросервисне архитектуре

Микросервисна архитектура уводи додатну сложеност и изазове:

**Повећана сложеност инфраструктуре** - Управљање са више десетина или стотина различитих сервиса захтева сложену инфраструктуру, алате за оркестрацију попут Kubernetes-а, service discovery механизме и напредне мониторинг системе.

**Мрежна латенција** - Комуникација између сервиса одвија се преко мреже, што уводи додатну латенцију у односу на директне позиве метода у монолитној апликацији. Ова латенција може значајно утицати на перформансе система.

**Сложеност deployовања** - Deployовање десетина сервиса захтева софистициране CI/CD pipeline-ове, контејнеризацију и оркестрацију. Координација верзија различитих сервиса може бити комплексна.

**Отежано тестирање** - Интеграционо тестирање је значајно сложеније када је потребно подићи више различитих сервиса. End-to-end тестирање захтева координацију свих релевантних сервиса.

**Дистрибуирана природа система** - Микросервисна архитектура доносе изазове својствене дистрибуираним системима, као што су eventual consistency, сложено управљање трансакцијама и потреба за distributed tracing механизмима.

**Оперативни overhead** - Потребно је управљати са више база података, мониторисати више сервиса, анализирати логове из различитих извора и координисати deployовање више компоненти.

**Већа потрошња ресурса** - Свака инстанца микросервиса захтева своје ресурсе (меморију, CPU). У окружењу са много малих сервиса, укупна потрошња ресурса може бити већа него код монолитне апликације.

## 2.3 Компаративна анализа архитектура

### 2.3.1 Критеријуми за поређење

При доношењу одлуке о избору архитектуре, неопходно је размотрити низ критеријума који укључују техничке, пословне и организационе аспекте:

**Перформансе система** - Време одзива апликације, пропусност (throughput), латенција при комуникацији између компоненти и ефикасност коришћења ресурса су кључне метрике перформанси које треба узети у обзир.

**Скалабилност** - Способност система да се прилагоди растућем броју корисника или података. Разматра се хоризонтално скалирање (додавање више инстанци) и вертикално скалирање (повећање ресурса постојећих инстанци).

**Поузданост и отпорност на грешке** - Способност система да настави са радом упркос грешкама у појединим компонентама, као и брзина опоравка након пада.

**Сложеност развоја и одржавања** - Количина времена и ресурса потребних за развој нових функционалности, исправљање грешака и одржавање постојећег кôда.

**Time-to-market** - Време потребно за развој и deployовање нових функционалности или измена.

**Величина тима и организација** - Број програмера, њихове вештине и начин организације развојног тима.

**Величина и природа апликације** - Сложеност пословних захтева, очекивани број корисника и очекивани раст апликације.

### 2.3.2 Препоруке за избор архитектуре

На основу карактеристика обе архитектуре, могу се дефинисати препоруке за њихову примену:

**Монолитна архитектура је препоручљива када:**

- Апликација је мања или средње величине са ограниченом сложеношћу
- Тим је мали (до 10 програмера) и централизован
- Захтеви су јасни и стабилни, без очекиваних честих промена
- Брзина развоја у раним фазама је критична
- Нема потребе за различитим технологијама за различите делове апликације
- Оптерećење система је релативно уједначено између различитих функционалности
- Инфраструктурни ресурси су ограничени

**Микросервисна архитектура је препоручљива када:**

- Апликација је велика и сложена са многобројним различитим функционалностима
- Тим је велик (више од 10 програмера) или постоји више тимова
- Потребно је независно скалирање различитих делова апликације
- Различите функционалности имају различите техничке захтеве
- Постоји потреба за континуалним deployовањем и брзим испоруком промена
- Апликација треба да буде отпорна на грешке са минималним утицајем пада појединих компоненти
- Организација има зрелу DevOps културу и инфраструктуру

### 2.3.3 Хибридни приступ

У пракси, многи системи користе хибридни приступ који комбинује елементе обе архитектуре. Такав приступ може укључивати:

**Модуларни монолит** - Монолитна апликација структурирана у јасно дефинисане модуле са лабавим везама, што олакшава евентуалну трансформацију у микросервисе.

**Постепена миграција** - Започињање са монолитном архитектуром и постепена екстракција критичних компоненти у засебне микросервисе како систем расте.

**Селективна употреба микросервиса** - Одржавање монолитног core система са издвајањем специфичних функционалности (нпр. обрада плаћања, нотификације) као засебних сервиса.

Овај приступ омогућава балансирање између једноставности монолитне архитектуре и флексибилности микросервисне архитектуре, приlagођавајући се специфичним потребама пројекта.
