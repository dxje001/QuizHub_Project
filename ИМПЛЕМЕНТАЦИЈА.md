# 3. ИМПЛЕМЕНТАЦИЈА СИСТЕМА КВИЗХАБ

У овом поглављу представљена је детаљна имплементација веб апликације КвизХаб у обе архитектуре - монолитној и микросервисној. Апликација је развијена са циљем да омогући креирање, управљање и извршавање квизова, као и праћење резултата корисника.

## 3.1 Преглед апликације КвизХаб

КвизХаб је веб апликација за управљање квизовима која омогућава корисницима да креирају, деле и решавају квизове из различитих области знања. Апликација подржава различите типове питања, категоризацију квизова, систем бодовања и праћење најбољих резултата.

### 3.1.1 Функционалне карактеристике

Апликација имплементира следеће кључне функционалности:

**Управљање корисницима** - Систем подржава регистрацију и аутентификацију корисника са различитим улогама (Administrator, Creator, User). Аутентификација је имплементирана коришћењем JWT (JSON Web Token) токена.

**Управљање квизовима** - Корисници са улогом Creator могу креирати квизове са више питања, дефинисати категорије, постављати временска ограничења и додељивати бодове. Сваки квиз може садржати произвољан број питања са више понуђених одговора.

**Извршавање квизова** - Корисници могу прегледати доступне квизове, покренути квиз, одговарати на питања у дефинисаном временском оквиру и након завршетка видети свој резултат.

**Категоризација** - Квизови су организовани по категоријама (нпр. Спорт, Историја, Наука) што олакшава претрагу и филтрирање.

**Праћење резултата** - Систем чува све резултате корисника и омогућава преглед њихових остварених постигнућа и рангирање према успешности.

### 3.1.2 Технолошки stack

За имплементацију апликације коришћене су следеће технологије:

**Backend технологије:**
- ASP.NET Core 8.0 - framework за развој веб API-ја
- Entity Framework Core 8.0 - ORM за рад са базом podataka
- PostgreSQL 15 - релациона база података
- JWT Bearer Authentication - за аутентификацију и ауторизацију
- Serilog - за логовање догађаја у апликацији

**Frontend технологије:**
- React 18.2 - JavaScript library за изградњу корисничког интерфејса
- TypeScript 5.2 - надградња JavaScript-а са статичким типовима
- Vite 5.0 - build tool и development сервер
- Tailwind CSS 3.3 - utility-first CSS framework
- React Router 6.20 - за рутирање у SPA апликацији
- Zustand 4.4 - state management библиотека
- Axios 1.6 - HTTP клијент за комуникацију са API-јем

**Инфраструктурне технологије:**
- Docker - контејнеризација апликације
- Docker Compose - оркестрација вишеконтејнерских апликација
- Nginx - веб сервер и reverse proxy (за микросервисну архитектуру)
- AWS EC2 - виртуелни сервер за deployовање (микросервиси)
- AWS RDS - управљана PostgreSQL база података (микросервиси)

## 3.2 Монолитна архитектура

### 3.2.1 Структура монолитне апликације

Монолитна верзија апликације организована је као јединствена ASP.NET Core апликација која обједињује све функционалности у једном пројекту. Структура пројекта следи Clean Architecture принципе са јасном поделом на слојеве:

```
backend/
├── src/
│   ├── KvizHub.API/           # Презентациони слој (Controllers, Program.cs)
│   ├── KvizHub.Application/   # Апликациони слој (Services, DTOs)
│   ├── KvizHub.Domain/        # Доменски слој (Entities, Interfaces)
│   └── KvizHub.Infrastructure/# Инфраструктурни слој (Data, Repositories)
```

**KvizHub.API** - Овај слој садржи API контролере који обрађују HTTP захтеве и враћају одговоре. Главни контролери су `AuthController` (аутентификација), `QuizController` (управљање квизовима), `CategoryController` (категорије) и `AdminController` (администрација).

**KvizHub.Application** - Апликациони слој садржи сервисе који имплементирају пословну логику. Овде су дефинисани сервиси као `AuthService`, `QuizService`, `ResultService` који енкапсулирају пословна правила и координирају рад са репозиторијумима.

**KvizHub.Domain** - Доменски слој садржи доменске ентитете (`User`, `Quiz`, `Question`, `Answer`, `Category`, `QuizResult`) и интерфејсе репозиторијума. Овај слој не зависи од других слојева.

**KvizHub.Infrastructure** - Инфраструктурни слој садржи имплементацију репозиторијума, `ApplicationDbContext` за Entity Framework Core, и скрипте за иницијализацију базе података.

### 3.2.2 База података

Монолитна апликација користи једну PostgreSQL базу података која садржи све табеле потребне за рад апликације. Главне табеле су:

- **AspNetUsers** - корисници система (укључујући Identity framework табеле)
- **Categories** - категорије квизова
- **Quizzes** - основни подаци о квизовима
- **Questions** - питања унутар квизова
- **Answers** - понуђени одговори за питања
- **QuizResults** - резултати корисника

Све табеле су повезане реляционим везама (foreign key constraints), што обезбеђује интегритет података. Entity Framework Core управља миграцијама и креирањем шеме базе података.

### 3.2.3 Deployovanje монолитне апликације

Монолитна апликација deployована је локално коришћењем Docker Compose-а. Дефинисана су три сервиса:

```yaml
services:
  postgres:      # PostgreSQL база података
  backend:       # ASP.NET Core API (порт 5000)
  frontend:      # React апликација (порт 3050)
```

Сви сервиси комуницирају преко private Docker мреже `kvizhub-network`. Backend апликација комуницира са PostgreSQL базом података користећи connection string, а frontend комуницира са backend-ом преко HTTP протокола на `http://localhost:5000`.

Процес deployовања је једноставан:
1. Покретање `docker-compose up -d` команде
2. Docker build-ује backend и frontend image-е
3. Контејнери се покрећу и међусобно се повезују
4. База података се иницијализује са основним seed подацима

## 3.3 Микросервисна архитектура

### 3.3.1 Структура микросервисне апликације

Микросервисна верзија апликације декомпонована је на три независна сервиса, где сваки сервис одговара за специфичан пословни домен:

```
backend/src/
├── KvizHub.AuthService/       # Сервис за аутентификацију
├── KvizHub.QuizService/       # Сервис за управљање квизовима
└── KvizHub.ExecutionService/  # Сервис за извршавање квизова
```

**AuthService (Authentication Service)** - Одговоран је за управљање корисницима, регистрацију, пријављивање и издавање JWT токена. Овај сервис има своју базу података која садржи табелу корисника и Identity framework табеле. Комуницира на порту 5001.

**QuizService (Quiz Management Service)** - Управља квизовима, питањима, одговорима и категоријама. Има засебну базу података са табелама `Quizzes`, `Questions`, `Answers` и `Categories`. За ауторизацију валидира JWT токене издате од AuthService-а. Комуницира на порту 5002.

**ExecutionService (Quiz Execution Service)** - Одговоран је за покретање квизова, прикупљање одговора корисника и чување резултата. Има своју базу података са табелом `QuizResults`. Комуницира са QuizService-ом да преузме податке о квизу и питањима, и са AuthService-ом за валидацију корисника. Комуницира на порту 5003.

### 3.3.2 Комуникација између сервиса

Микросервиси комуницирају међусобно коришћењем синхроних HTTP/REST позива. Сваки сервис излаже HTTP API који други сервиси могу да позову.

**Пример комуникације при извршавању квиза:**

1. Корисник шаље захтев frontend-у да покрене квиз
2. Frontend шаље HTTP POST захтев до ExecutionService-а
3. ExecutionService валидира JWT токен (може позвати AuthService)
4. ExecutionService позива QuizService да преузме податке о квизу
5. ExecutionService креира session за извршавање квиза
6. Корисник одговара на питања
7. ExecutionService израчунава резултат и чува га у својој бази
8. Frontend приказује резултат кориснику

Ова синхрона комуникација уводи мрежну латенцију јер сваки HTTP захтев пролази кроз мрежу, што је један од кључних фактора који утичу на перформансе микросервисне архитектуре.

### 3.3.3 API Gateway

За управљање рутирањем захтева користи се Nginx као API Gateway. Nginx је конфигурисан да рутира захтеве на основу URL путање до одговарајућег микросервиса:

```
/api/auth/**          → AuthService (port 5001)
/api/category/**      → QuizService (port 5002)
/api/quiz/**          → QuizService (port 5002)
/api/execution/**     → ExecutionService (port 5003)
/api/results/**       → ExecutionService (port 5003)
```

API Gateway обезбеђује јединствену тачку уласка за frontend апликацију и скрива сложеност микросервисне архитектуре од клијента. Такође обрађује CORS (Cross-Origin Resource Sharing) захтеве и може имплементирати rate limiting и load balancing.

### 3.3.4 Независне базе података

Сваки микросервис има своју засебну базу података, што је један од кључних принципа микросервисне архитектуре. У deployованој верзији на AWS-у, коришћене су следеће базе:

- **auth-db** - PostgreSQL база за AuthService (корисници и улоге)
- **quiz-db** - PostgreSQL база за QuizService (квизови, питања, категорије)
- **results-db** - PostgreSQL база за ExecutionService (резултати корисника)

Све три базе података deployоване су као засебне AWS RDS инстанце. Овај приступ обезбеђује потпуну независност сервиса, али отежава имплементацију трансакција које би обухватале више сервиса.

### 3.3.5 Deployовање микросервисне апликације

Микросервисна архитектура deployована је на AWS облаку коришћењем следећих компоненти:

**AWS EC2** - Виртуелна машина са Elastic IP адресом `44.208.207.182` на којој су deployовани Docker контејнери са микросервисима и Nginx gateway-ом.

**AWS RDS** - Три засебне PostgreSQL RDS инстанце за сваки микросервис. RDS обезбеђује управљане базе података са аутоматским backup-ом и high availability опцијама.

**Docker Compose** - На EC2 инстанци користи се Docker Compose за оркестрацију свих микросервиса. Конфигурација дефинише четири сервиса:

```yaml
services:
  api-gateway:        # Nginx reverse proxy (port 80)
  auth-service:       # Authentication (port 5001)
  quiz-service:       # Quiz management (port 5002)
  execution-service:  # Quiz execution (port 5003)
```

**Процес deployовања:**

1. Креирање EC2 инстанце и доделa Elastic IP адресе
2. Креирање RDS база података за све сервисе
3. Build Docker image-а за све микросервисе
4. Push image-а у Docker Hub или AWS ECR
5. Конфигурисање environment променљивих (connection strings, JWT secret)
6. Покретање `docker-compose up -d` на EC2 инстанци
7. Конфигурисање Nginx-а за рутирање захтева
8. Отварање потребних портова у AWS Security Group (80, 443)

Elastic IP адреса обезбеђује да се IP адреса не мења након рестартовања EC2 инстанце, што је важно за стабилност система и перформанс тестове.

## 3.4 Frontend апликација

Frontend апликација је идентична за обе архитектуре и комуницира са backend-ом искључиво преко HTTP API-ја. Апликација је имплементирана као Single Page Application (SPA) коришћењем React framework-а.

### 3.4.1 Структура frontend апликације

```
frontend/src/
├── components/      # Компоненте корисничког интерфејса
├── pages/          # Странице апликације
├── services/       # HTTP клијенти за комуникацију са API-јем
├── stores/         # Zustand state management
├── types/          # TypeScript type дефиниције
└── utils/          # Помоћне функције
```

**Главне странице апликације:**
- Login / Register - Аутентификација корисника
- Dashboard - Преглед доступних квизова
- Quiz Detail - Детаљи појединачног квиза
- Quiz Taking - Решавање квиза са питањима
- Results - Преглед резултата
- Admin Panel - Администраторски панел (креирање квизова)

### 3.4.2 Комуникација са backend-ом

Frontend комуницира са backend-ом користећи Axios HTTP клијент. Конфигурација базног URL-а се разликује између монолитне и микросервисне архитектуре:

**Монолитна архитектура:**
```typescript
baseURL: 'http://localhost:5000'
```

**Микросервисна архитектура:**
```typescript
baseURL: 'http://44.208.207.182'
```

Axios је конфигурисан са interceptor-има који аутоматски додају JWT токен у Authorization header за све захтеве, као и error handling који обрађује 401 Unauthorized и друге грешке.

### 3.4.3 State management

Апликација користи Zustand за управљање глобалним стањем. Главни store-ови су:

- **authStore** - Чува податке о пријављеном кориснику и JWT токен
- **quizStore** - Управља листом квизова и тренутно селектованим квизом
- **themeStore** - Управља dark/light темом

Zustand је изабран због једноставности и перформанси у односу на Redux, а обезбеђује довољну функционалност за потребе ове апликације.

## 3.5 Разлике у имплементацији

### 3.5.1 Архитектурне разлике

Кључна разлика између монолитне и микросервисне имплементације је у организацији кôда и deployовању:

**Монолит:**
- Један пројекат са унутрашњим модулима
- Директни позиви метода између слојева
- Једна база података са foreign key constraint-има
- Једноставан deployment процес (један Docker image)
- Комуникација у меморији без мрежне латенције

**Микросервиси:**
- Три засебна пројекта са независним deployовањем
- HTTP API позиви између сервиса преко мреже
- Три засебне базе података без директних веза
- Сложенији deployment са више Docker image-а и Nginx gateway-ом
- Мрежна комуникација уводи додатну латенцију

### 3.5.2 Перформансне импликације

Архитектурне разлике директно утичу на перформансе система:

**Мрежна латенција** - Микросервисна архитектура захтева мрежну комуникацију за сваки позив између сервиса, док монолит користи директне позиве метода у меморији. Ова разлика је посебно изражена када је микросервисна архитектура deployована на AWS-у, а монолит локално.

**Серијализација података** - Микросервиси морају серијализовати и десеријализовати податке у JSON формат за сваки HTTP захтев, што додаје overhead. Монолит директно прослеђује објекте у меморији.

**Connection overhead** - Сваки HTTP позив између микросервиса успоставља TCP connection, што уводи додатну латенцију. Монолит нема овај overhead јер је све у истом процесу.

**Atabase connections** - Микросервиси захтевају connection pool за сваку базу података, док монолит користи један connection pool за једну базу.

Ове разлике биће детаљно анализиране у поглављу о резултатима перформанс тестова.
